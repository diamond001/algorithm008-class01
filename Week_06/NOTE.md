动态规划法

该问题可以通过动态规划的方法进行求解，我们假设s[i]代表一条长度为i的消息,对应的解码方法的总数为dp[i]，那么这个值的大小和dp[i-1]以及dp[i-2]相关，因为解码时只有一位或者两位字符可以作为一个原码看待。当我们假设这条消息的最后一位作为原码时，它的取值范围为

‘1’ ~ ’ 9’，需要满足条件：s[i-1] != ‘0’；当我们假设这条消息的最后两位作为一个原码时，它的取值范围为 ‘10’~‘26’，需要满足条件 s[i-2] == ‘1’ || (s[i-2] == ‘2’ && s[i-1] <= ‘6’)。



 int numDecodings(string s) {

​    if(s.empty() || (s[0] == '0'))

​      return 0;

​    int n = s.size();

​    vector<int> dp(n+1,0);

​    dp[0] = 1;

​    dp[1] = (s[0] == '0') ? 0 :1;

​    for(int i = 2; i <= n; i++)

​    {

​      int t = (i > 1 && (s[i-2] == '1' || (s[i-2]== '2' && s[i-1] <= '6')));

​      int l = (s[i-1] != '0')?1:0;

​      dp[i] = l*dp[i-1] + dp[i-2]*t;

​    }

​    return dp[n];

  }